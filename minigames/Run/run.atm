val sdl = require "atmos.env.sdl"
val SDL = require "SDL"
val TTF = require "SDL.ttf"
val IMG = require "SDL.image"

val w_screen, h_screen = (350,350)
val PI = 3.1415

set FNT = TTF.open("tiny.ttf", 15) --> assert ;;Trocar fonte para Arial
math.randomseed()

val score = 0

val _, REN = sdl.window @{
	title  = "Game 1 - Run",
	width = w_screen,
	height = h_screen,
	flags = @{ SDL.flags.OpenGL },
} --> assert

val sprite_enemy1 = tex where{
	sfc = IMG.load("run/enemy1.png") -->assert
	tex = REN::createTextureFromSurface(sfc) -->assert
}

val sprite_enemy2 = tex where{
	sfc = IMG.load("run/enemy2.png") -->assert
	tex = REN::createTextureFromSurface(sfc) -->assert
}

val sprite_player = tex where{
	sfc = IMG.load("run/player.png") -->assert
	tex = REN::createTextureFromSurface(sfc) -->assert
}

;; Background (cor #34495e)
spawn{
	val color = @{r=52, g=73, b=94}
	every :sdl.draw{
		REN::setDrawColor(color)
		REN::clear()
	}
}

func random_signal (){
	if (math.random(0,1) == 1) => 1 => -1
}

func check_lim (min, max, num){
	ifs{
		num > max => max
		num < min => min
		else	=> num
	}
}

func player (x0,y0){
	val rect = @{ x = (x0 - 20)/2,
	y = (y0 - 24)/2,
	w = 20,
	h = 24 }
	val color = @{r=0,g=0,b=255}
	
	set pub = @{
		rect = rect
	}
	
	par {
		every it in SDL.event.KeyDown {
			match it.name{
				'Up' => set rect.y = check_lim (0, h_screen - rect.h, rect.y - 5)
				'Down' => set rect.y = check_lim (0, h_screen - rect.h, rect.y + 5)
				'Left' => set rect.x = check_lim (0, w_screen - rect.w, rect.x - 5)
				'Right' => set rect.x = check_lim (0, w_screen - rect.w, rect.x + 5)
			}
		}
	} with {
			
		every :sdl.draw{
			val crop = @{ x=0, y=0, w=20, h=24 }
        			REN::copy(sprite_player, crop, sdl.ints(rect))
		}
	}
}


func enemy1 (x0, y0, angle){
	val rect = @{ x= x0 , y= y0, w = 32, h = 36 }
	val speed = w_screen/3 
	
	set pub = @{
		rect = rect
	}
	
	watching \{ (rect.x>w_screen) || (rect.y>h_screen) } {
		par {
        		every _, ms in :clock {
          			val ds = (speed * ms) / 1000.0
            
            			set rect.x = rect.x + (ds * math.cos(angle))
            			set rect.y = rect.y + (ds * math.sin(angle))
        		}
        	} with{
        		every :sdl.draw {
        			val crop = @{ x=0, y=0, w=32, h=36 }
        			REN::copy(sprite_enemy1, crop, sdl.ints(rect))
        		}
        	}
        }
}

func enemy2 (x0, y0, angle){
	val rect = @{ x= x0 , y= y0, w = 32, h = 36 }
	val speed = w_screen/3 
	val color = @{r=255,g=0,b=0}
	
	set pub = @{
		rect = rect
	}
	
	watching \{ (rect.x>w_screen) || (rect.y>h_screen) } {
		par {
        		every _, ms in :clock {
          		val ds = (speed * ms) / 1000.0
            
            		set rect.x = rect.x + (ds * math.cos(angle))
            		set rect.y = rect.y + (ds * math.sin(angle))
        		}
        	} with{
        		every :sdl.draw {
        			val crop = @{ x=0, y=0, w=32, h=36 }
        			REN::copy(sprite_enemy2, crop, sdl.ints(rect))
        		}
        	}
        }
}
	
loop{
	pin enemies1 = tasks(30)
	pin enemies2 = tasks(30)
	pin single_player = spawn player (w_screen, h_screen)

	var who, spawn_side, x_spawn, y_spawn, angle
	
	var score = 0
	var message = "use the arrow keys to move"
	
	spawn{
		every @1{
			set score = score + 1
		}
	}
	
	;;refazer: contar @3 apÃ³s Up
	spawn {
		val color_txt = @{r = 255, g = 255, b = 255}
		val sfc_txt = FNT::renderUtf8("use the arrow keys to move", "blended", color_txt) --> assert
		val tex_txt = REN::createTextureFromSurface(sfc_txt) --> assert
		
		val rect_txt = @{ x = (w_screen/2) - 100,
			y = (h_screen/2) + 50, w = 200, h = 20 }
			
		;;await(SDL.event.KeyDown, 'Up')
		watching @2 {
		    every :sdl.draw {
			REN::setDrawColor(@{r=255,g=255,b=255})
			REN::copy(tex_txt, nil, sdl.ints (rect_txt))
		    }
	    	}
	}
		
	spawn {
	    val rect_pos = sdl.pct_to_pos(15, 10)
	    every :sdl.draw {
		REN::setDrawColor(@{r=255,g=255,b=255})
		sdl.write(FNT, tostring(score), rect_pos)
	    }
	}

	watching :collided {
		par{
			every @.500 {
				set spawn_side = math.random(1, 4)
				match spawn_side {
					1 => { 
				    		set x_spawn = 0
				 		set y_spawn = math.random(0, h_screen)
				 		set angle = (math.random() * PI) - (PI/2)
			       		}
					2 => { 
				    		set x_spawn = w_screen
				    		set y_spawn = math.random(0, h_screen)
				    		set angle = (PI/2) + (math.random() * PI)
					}
					3 => { 
				    		set x_spawn = math.random(0, w_screen)
				    		set y_spawn = 0
				    		set angle = math.random() * PI
					}
					4 => { 
						set x_spawn = math.random(0, w_screen)
				    		set y_spawn = h_screen
				    		set angle = PI + (math.random() * PI)
					}
				}
				
				set who = math.random(1,2)
				match who {
					1 => spawn [enemies1] enemy1( x_spawn, y_spawn, angle)
					2 => spawn [enemies2] enemy2( x_spawn, y_spawn, angle)
				}
			}
		} with{
			every :clock {
				loop _, e1 in enemies1 {
					if sdl.rect_vs_rect(single_player.pub.rect, e1.pub.rect) {
			    			emit :collided
			    		}
			    	}
			    	loop _, e2 in enemies2 {
					if sdl.rect_vs_rect(single_player.pub.rect, e2.pub.rect) {
			    			emit :collided
			    		}
			    	}
			}
		}
        }
        
        await(SDL.event.KeyDown, 'Up')
}
