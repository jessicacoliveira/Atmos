require "atmos.env.pico"
set pico = require "pico"

val w_screen, h_screen = (350,350)
val PI = 3.1415

math.randomseed()

pico.zet.title "Game 1 - Run"
val dim = @{ "!", w = 350, h = 350 }
pico.zet.view @{ window=dim, world=dim }

spawn{
	every :draw{
		pico.zet.color.clear(52,73,94)
		pico.output.clear ()
	}
}

func check_lim (min, max, num){
	ifs{
		num > max => max
		num < min => min
		else	=> num
	}
}

func player3 (x0,y0){
    val rect = @{ '!', x = (x0 - 20)/2, y = (y0 - 24)/2, w = 20, h = 24 }
    val dim = pico.get.image("run/player.png")
    
    var frame_idx = 0
    var linha_idx = 3 ;; 0=Down, 2=Up, 1=Right, 3=Left
    val total_frames = 2
    
    set pub = @{
        rect = rect
    }
    
    par {
        every it in :key.dn {
            match it.key {
                'Up'    => { 
                    set rect.y = check_lim (0 + (rect.h/2), h_screen - (rect.h/2), rect.y - 10)
                    set frame_idx = (frame_idx + 1) % total_frames
                    set linha_idx = 2
                }
                'Down'  => { 
                    set rect.y = check_lim (0, h_screen - (rect.h/2), rect.y + 10)
                    set frame_idx = (frame_idx + 1) % total_frames
                    set linha_idx = 0
                }
                'Left'  => { 
                    set rect.x = check_lim (0 + (rect.w/2), w_screen - (rect.w/2), rect.x - 10)
                    set frame_idx = (frame_idx + 1) % total_frames
                    set linha_idx = 3
                }
                'Right' => { 
                    set rect.x = check_lim (0 + (rect.w/2), w_screen - (rect.w/2), rect.x + 10)
                    set frame_idx = (frame_idx + 1) % total_frames
                    set linha_idx = 1
                }
            }
        }
    } with {
        every :draw {
            val crop_x = frame_idx * rect.w
            val crop_y = linha_idx * rect.h
            
            pico.zet.crop @{ '!', x = crop_x, y = crop_y, w = rect.w, h = rect.h }
            pico.output.draw.image("run/player.png", rect)
            pico.zet.crop()
        }
    }
}

func enemy1 (x0, y0, angle){
    val rect = @{ '!', x= x0 , y= y0, w = 32, h = 36 }
    val speed = w_screen/2
    val dim = pico.get.image("run/enemy1.png")
    
    var timer = 0
    var frame_idx = 0
    val total_frames = 2
    
    set pub = @{
        rect = rect
    }
    
    watching \{ (rect.x > w_screen) || (rect.x < -rect.w) || (rect.y > h_screen) || (rect.y < -rect.h) }, :collided {
        par {
            every _, ms in :clock {
                val ds = (speed * ms) / 1000.0
                set rect.x = rect.x + (ds * math.cos(angle))
                set rect.y = rect.y + (ds * math.sin(angle))
                
                ;; 5fps = 200ms?
                set timer = timer + ms
                if timer >= 200 {
                    set frame_idx = (frame_idx + 1) % total_frames
                    set timer = 0
                }
            }
        } with {
            every :draw {
                val crop_x = frame_idx * rect.w
                if (crop_x + rect.w) <= dim.w {
                    pico.zet.crop @{ '!', x = crop_x, y = 0, w = rect.w, h = rect.h }
                    pico.output.draw.image("run/enemy1.png", rect)
                    pico.zet.crop()
                } else {
                    pico.output.draw.image("run/enemy1.png", rect)
                }
            }
        }
    }
}

func enemy2 (x0, y0, angle){
    val rect = @{ '!', x= x0 , y= y0, w = 28, h = 40 }
    val speed = w_screen/2
    val dim = pico.get.image("run/enemy2.png")
    
    var timer = 0
    var frame_idx = 0
    val total_frames = 2
    
    set pub = @{
        rect = rect
    }
    
    watching \{ (rect.x > w_screen) || (rect.x < -rect.w) || (rect.y > h_screen) || (rect.y < -rect.h) }, :collided {
        par {
            every _, ms in :clock {
                val ds = (speed * ms) / 1000.0
                set rect.x = rect.x + (ds * math.cos(angle))
                set rect.y = rect.y + (ds * math.sin(angle))
                
                ;; 5fps = 200ms?
                set timer = timer + ms
                if timer >= 200 {
                    set frame_idx = (frame_idx + 1) % total_frames
                    set timer = 0
                }
            }
        } with {
            every :draw {
                val crop_x = frame_idx * rect.w
                if (crop_x + rect.w) <= dim.w {
                    pico.zet.crop @{ '!', x = crop_x, y = 0, w = rect.w, h = rect.h }
                    pico.output.draw.image("run/enemy2.png", rect)
                    pico.zet.crop()
                } else {
                    pico.output.draw.image("run/enemy2.png", rect)
                }
            }
        }
    }
}
	
loop{
	pin enemies1 = tasks(30)
	pin enemies2 = tasks(30)
	pin single_player = spawn player3 (w_screen, h_screen)

	var who, spawn_side, x_spawn, y_spawn, angle
	
	var score = 0
	
	spawn{
		toggle :timer{
			every @1{
				set score = score + 1
			}
		}
	}
	
	;;esquisito, porém o texto deve desaparecer algum tempo após o player apertar qualquer tecla (n consegui fazer de outra forma)
	spawn {
		;;val txt_pos = @{ '!', x = ((w_screen/2) - 100), y = ((h_screen/2) + 50)}
		val txt_pos = @{ '%', x=0.5, y=0.6, h=0.065 }
		par{
			await(:key.dn, 'Up')
			emit :warning
			watching @.8 {
				    every :draw {
					pico.zet.color.draw "white"
					pico.output.draw.text("use the arrow keys to move", txt_pos)
				    }
			}
		}with{
			watching :warning{
				    every :draw {
					pico.zet.color.draw "white"
					pico.output.draw.text("use the arrow keys to move", txt_pos)
				    }
			}
		}
	}
		
	spawn {
	    val txt_pos = @{ '%', x=0.2, y=0.1, h=0.075 }
	    every :draw {
	    	pico.zet.color.draw "white"
			pico.output.draw.text("score:" ++ score, txt_pos)
	    }
	}

	watching :collided {
		par{
			every @.300 {
				set spawn_side = math.random(1, 4)
				match spawn_side {
					1 => { 
				    		set x_spawn = 0
				 			set y_spawn = math.random(0, h_screen)
				 			set angle = (math.random() * PI) - (PI/2)
			       		}
					2 => { 
				    		set x_spawn = w_screen
				    		set y_spawn = math.random(0, h_screen)
				    		set angle = (PI/2) + (math.random() * PI)
					}
					3 => { 
				    		set x_spawn = math.random(0, w_screen)
				    		set y_spawn = 0
				    		set angle = math.random() * PI
					}
					4 => { 
						set x_spawn = math.random(0, w_screen)
				    		set y_spawn = h_screen
				    		set angle = PI + (math.random() * PI)
					}
				}
				
				set who = math.random(1,2)
				match who {
					1 => spawn [enemies1] enemy1( x_spawn, y_spawn, angle)
					2 => spawn [enemies2] enemy2( x_spawn, y_spawn, angle)
				}
			}
		} with{
			every :clock {
				loop _, e1 in enemies1 {
					if pico.vs.rect_rect(single_player.pub.rect, e1.pub.rect) {
			    			emit (:timer, false)
			    			emit :collided
			    			
			    		}
			    	}
			    	loop _, e2 in enemies2 {
					if pico.vs.rect_rect(single_player.pub.rect, e2.pub.rect) {
			    			emit (:timer, false)
			    			emit :collided
			    		}
			    	}
			}
		}
	}

	pico.output.sound "run/hit.wav"
	
	;;\n não funciona... teria algo do tipo em atmos/pico-atmos ou só quebrando o texto?
	spawn{
		val txt_GG = @{ '%', x=0.5, y=0.2, h=0.075 }
		val txt_score = @{ '%', x=0.5, y=0.4, h=0.075 }
		val txt_restart = @{ '%', x=0.5, y=0.6, h=0.075 }
		val txt_restart2 = @{ '%', x=0.5, y=0.7, h=0.075 }
		
		every :draw {
			pico.output.clear ()
			pico.zet.color.draw "white"
			
			pico.output.draw.text("Game Over", txt_GG)
			pico.output.draw.text(("Score: " ++ score), txt_score)
			pico.output.draw.text("press the UP arrow key", txt_restart)
			pico.output.draw.text("to restart", txt_restart2)
			
		    }
	}
	await(:key.dn, 'Up')
	emit (:timer, true)
}
