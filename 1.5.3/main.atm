val sdl = require "atmos.env.sdl"
val SDL = require "SDL"

val w_screen, h_screen = (200, 200)
math.randomseed()

val _, REN = sdl.window @{
	title  = "Ex. 1.5.3 - Atmos",
	width = w_screen,
	height = h_screen,
	flags = @{ SDL.flags.OpenGL },
} --> assert

spawn{
	val color = @{r=255, g=255, b=255}
	every :sdl.draw{
		REN::setDrawColor(color)
		REN::clear()
	}
}

func check_lim (min, max, num){
	ifs{
		num > max => max
		num < min => min
		else	=> num
	}
}

func aux_func (rect){
	ifs {
                rect.x < 0 => true
                rect.x > (w_screen - rect.w) => true
                rect.y < 0 => true
                rect.y > (h_screen - rect.h) => true
                else       => false
            }
}

func set_stop(stop){
	ifs{
		stop == 0 => 1
		stop == 1 => 0
	}
}


func Rect_Anima (x0,y0){
	val rect_size = 20
	val rect = @{ x = check_lim (0, w_screen, x0),
	y = check_lim (0, h_screen, y0),
	w = rect_size,
	h = rect_size }
	val color = @{r=0,g=0,b=255}
	
	var rx, ry, stop, dv = (1, 1, 1, 2)
	spawn{
		every it in SDL.event.KeyDown {
			match it.name{
				'A' => set rx, ry = ((-1)*rx, (-1)*ry)
				'S' => set rect.w, rect.h = ((rect.w + 1), (rect.h + 1))
				'X' => set rect.w, rect.h = ((rect.h - 1), (rect.h - 1))
				'Space' => set stop = set_stop(stop)
				'T' => set color.r, color.g, color.b = (math.random(0,200), math.random(0,200), math.random(0,200))
				'D' => set dv = dv + 2
				'C' => set dv = check_lim(1, 10, dv - 2)
			}
		}
	}
	
	par {
		loop{
			watching (\{(rect.x > (w_screen - rect.w))} || aux_func(rect)) {
				every _,ms in :clock {		
					set rect.x = rect.x + ((rx*dv) * stop)
				}
			}
			set rx = (-1)*rx
			
			watching (\{rect.y > (h_screen - rect.h)} || aux_func(rect)){
				every _,ms in :clock {		
					set rect.y = rect.y + ((ry*dv)*stop)
				}
			}
			set ry = (-1)*ry
			
			watching (\{rect.x < 0} || aux_func(rect)){
				every _,ms in :clock {		
					set rect.x = rect.x + ((rx*dv)*stop)
				}
			}
			set rx = (-1)*rx
			
			watching (\{rect.y < 0 } || aux_func(rect)){
				every _,ms in :clock {		
					set rect.y = rect.y + ((ry*dv)*stop)
				}
			}
			set ry = (-1)*ry
			
			
		}
	}with {
		every :sdl.draw{
			REN::setDrawColor(color)
			REN::fillRect(sdl.ints (rect))
		}
	}
}


spawn Rect_Anima (0,0)

await(false)
			
			
